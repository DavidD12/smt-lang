use std::str::FromStr;
use crate::problem::*;
use super::*;
use line_col::LineColLookup;
use fraction::Fraction;
// use std::time::Duration;

grammar<'a>(lookup: &LineColLookup<'input>, parser: &mut Parser<'a>);

match {
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _
}

//------------------------- Problem -------------------------

pub Problem: () = Entry* => {};

//------------------------- Entry -------------------------

Entry: () = {
    Include,
    Structure,
    Instance,
    Variable,
    Function,
    Constraint,
};

//------------------------- Include -------------------------

Include: () = "include" <file:String> => {
    parser.add(file);
};

//------------------------- Structure -------------------------

Structure: () = "struct" <i:Identifier> "{" <elts:StructureElement*> "}" => {
    let position = Some(i.position.clone());
    let mut structure = Structure::new(i.name, position);
    for e in elts.iter() {
        match e {
            StructureElement::Attribute(a) => {
                structure.add_attribute(a.clone());
            },
            StructureElement::Method(m) => {
                structure.add_method(m.clone());
            }
        }
    }
    parser.problem.add_structure(structure);
};

StructureElement: StructureElement = {
    <a:StrucAttribute> => StructureElement::Attribute(a),
    <m:StrucMethod> => StructureElement::Method(m),
};

//------------------------- Instance -------------------------

Instance: () = "inst" <l:Identifiers> ":" <s:Identifier> => {
    for i in l {
        let struct_ref = StructureRef::Unresolved(s.name.clone(), Some(s.position.clone()));
        let position = Some(i.position.clone());
        let inst = Instance::new(i.name, struct_ref, position);
        parser.problem.add_instance(inst);
    }
}; 

//------------------------- Strcuture Attribute -------------------------

StrucAttribute: Attribute<StructureId> = <i:Identifier> ":" <t:Type> <e:Assign?> => {
    let position = Some(i.position.clone());
    Attribute::new(i.name, t, e, position)
};

//------------------------- Structure Method -------------------------

StrucMethod: Method<StructureId> = <i:Identifier> "(" <p:StrucMetParameters> ")" ":" <t:Type> <e:Assign?> => {
    let position = Some(i.position.clone());
    let mut m = Method::new(i.name, t, e, position);
    for x in p {
        m.add_parameter(x);
    }
    m
};   

//------------------------- Method Parameter -------------------------

StrucMetParameter: Parameter<MethodId<StructureId>> = <i:Identifier> ":" <t:Type> => {
    let position = Some(i.position.clone());
    Parameter::new(i.name, t, position)
};

StrucMetParameters: Vec<Parameter<MethodId<StructureId>>> = <p:StrucMetParameter> <l:StrucMetParameterNext*> => {
    let mut parameters = Vec::new();
    parameters.push(p);
    parameters.extend(l);
    parameters
};

StrucMetParameterNext: Parameter<MethodId<StructureId>> = "," <p:StrucMetParameter> => p;

//------------------------- Variable -------------------------

Variable: () = "let" <l:Identifiers> ":" <t:Type> <e:Assign?> => {
    for i in l {
        let position = Some(i.position.clone());
        let v = Variable::new(i.name, t.clone(), e.clone(), position);
        parser.problem.add_variable(v);
    }
};    

//------------------------- Function -------------------------

Function: () = "let" <i:Identifier> "(" <p:FunParameters> ")" ":" <t:Type> <e:Assign?> => {
    let position = Some(i.position.clone());
    let mut f = Function::new(i.name, t, e, position);
    for x in p {
        f.add_parameter(x);
    }
    parser.problem.add_function(f);
};    

//------------------------- Function Parameter -------------------------

FunParameter: Parameter<FunctionId> = <i:Identifier> ":" <t:Type> => {
    let position = Some(i.position.clone());
    Parameter::new(i.name, t, position)
};

FunParameters: Vec<Parameter<FunctionId>> = <p:FunParameter> <l:FunParameterNext*> => {
    let mut parameters = Vec::new();
    parameters.push(p);
    parameters.extend(l);
    parameters
};

FunParameterNext: Parameter<FunctionId> = "," <p:FunParameter> => p;

//------------------------- Constraint -------------------------

Constraint: () = "constraint" <i:Identifier> <e:Assign> => {
    let position = Some(i.position.clone());
    let c = Constraint::new(i.name, e, position);
    parser.problem.add_constraint(c);
};    

//------------------------- Assign -------------------------

Assign: Expr = "=" <e:Expr> => e;

//========================= Type =========================

Type: Type = {
    "Bool" => Type::Bool,
    "Int"  => Type::Int,
    "Real" => Type::Real,
    <min:Integer> ".." <max:Integer> => Type::Interval(min as isize, max as isize),
    <i:Identifier> => Type::Unresolved(i.name, Some(i.position)),
};

//========================= Expr =========================

Expr: Expr = ImpliesOrExpr;

ImpliesOrExpr: Expr = {
    <left:ImpliesOrExpr> <l:@L><op:ImpliesOrOp> <right:AndExpr> => {
        let position = Some(Position::new(parser.file(), lookup, l));
        Expr::Binary(Box::new(left), op, Box::new(right), position)
    },
    AndExpr,
};

AndExpr: Expr = {
    <left:AndExpr> <l:@L>"and" <right:CompExpr> => {
        let position = Some(Position::new(parser.file(), lookup, l));
        Expr::Binary(Box::new(left), BinOp::And, Box::new(right), position)
    },
    CompExpr,
};

CompExpr: Expr = {
    <left:CompExpr> <l:@L><op:CompOp> <right:AddSubExpr> => {
        let position = Some(Position::new(parser.file(), lookup, l));
        Expr::Binary(Box::new(left), op, Box::new(right), position)
    },
    AddSubExpr,
};

AddSubExpr: Expr = {
    <left:AddSubExpr> <l:@L><op:AddSubOp> <right:MulDivExpr> => {
        let position = Some(Position::new(parser.file(), lookup, l));
        Expr::Binary(Box::new(left), op, Box::new(right), position)
    },
    MulDivExpr,
};

MulDivExpr: Expr = {
    <left:MulDivExpr> <l:@L><op:MulDivOp> <right:PreExpr> => {
        let position = Some(Position::new(parser.file(), lookup, l));
        Expr::Binary(Box::new(left), op, Box::new(right), position)
    },
    PreExpr,
};

PreExpr: Expr = {
    <l:@L><op:PreOp> <e: PreExpr> => {
        let position = Some(Position::new(parser.file(), lookup, l));
        Expr::Prefix(op, Box::new(e), position)
    },
    FunCallExpr,
};

FunCallExpr: Expr = {
    <i:Identifier> <p:TupleExpr> => {
        let position = Some(i.position);
        Expr::UnresolvedFunCall(i.name, p, position)
    },
    StructExpr,
};

StructExpr: Expr = {
    <e:StructExpr> "." <i:Identifier> <p:TupleExpr> => {
        let position = Some(i.position);
        Expr::UnresolvedMethCall(Box::new(e), i.name, p, position)
    },
    <e:StructExpr> "." <i:Identifier> => {
        let position = Some(i.position);
        Expr::UnresolvedAttribute(Box::new(e), i.name, position)
    },
    Term,
};

Term: Expr = {
    <l:@L> <b:Boolean> => {
        let position = Position::new(parser.file(), lookup, l);
        Expr::BoolValue(b, Some(position))
    },
    <l:@L> <i:Integer> => {
        let position = Position::new(parser.file(), lookup, l);
        Expr::IntValue(i as isize, Some(position))
    },
    <l:@L> <d:Decimal> => {
        let position = Position::new(parser.file(), lookup, l);
        Expr::RealValue(d, Some(position))
    },
    <x:Identifier> => Expr::Unresolved(x.name, Some(x.position)),
    "(" <Expr> ")",
};

TupleExpr: Vec<Expr> = "(" <e:Expr> <l:CommaExpr*> ")" => {
    let mut v = Vec::new();
    v.push(e);
    v.extend(l);
    v
};
CommaExpr: Expr = "," <e:Expr> => e;

//------------------------- Operator -------------------------

ImpliesOrOp: BinOp = {
    "=>" => BinOp::Implies,
    "or" => BinOp::Or,
};

CompOp: BinOp = {
    "=" => BinOp::Eq,
    "/=" => BinOp::Ne,
    "<" => BinOp::Lt,
    "<=" => BinOp::Le,
    ">=" => BinOp::Ge,
    ">" => BinOp::Gt,
};

AddSubOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

MulDivOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

PreOp: PreOp = {
    "not" => PreOp::Not,
    "-" => PreOp::Minus,
};

//========================= Util =========================

CommaOne<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
};

CommaIdentifier: Identifier = "," <i:Identifier> => i;

Identifiers: Vec<Identifier> = <i:Identifier> <l:CommaIdentifier*> => {
    let mut v = Vec::new();
    v.push(i);
    v.extend(l);
    v
};

//========================= Lexer =========================

String: String = <s:r#"".+""#> => s[1..s.len()-1].to_string();

// Duration: Duration = {
//     <i:UInteger> "sec" => Duration::from_secs(i),
//     <i:UInteger> "ms" => Duration::from_millis(i),
// };

Boolean: bool = {
    "false" => false,
    "true" => true,
};

Integer: i64 = <i:r"-?[0-9]+"> => i.parse::<i64>().unwrap();

// UInteger: u64 = <i:r"[0-9]+"> => i.parse::<u64>().unwrap();

Decimal: Fraction = <d:r"[0-9]+\.[0-9]+"> => Fraction::from_str(d).unwrap();

Identifier: Identifier = <l:@L> <s:r"[a-zA-Z][a-zA-Z_0-9]*"> <r:@R> => {
    Identifier::new(parser.file(), lookup, s, l)
};